\documentclass[multi,crop=false,class=article]{standalone}

\newcommand{\concat}{\cdot} 

\begin{document}
\section{Fundamental Theory}
\label{sec:fundamental-theory}

Angluin defines the $L^*$ algorithm for learning regular sets\cite{Angluin87}.
The goal of the algorithm is to discover a model that corresponds to the regular
set (`the target').

The target is said to contain only \textit{words}, where each word consists
of the concatenation of zero or more items from a certain set of of symbols
called the input alphabet $A$.

The algorithm requires a so called \textit{minimally adequate teacher} which can
answer two types of questions about the target. The first is a membership query;
it answers whether a given word is accepted by the target. The second is an
equivalence query: given a hypothesis, it answers `yes' if the hypothesis
exactly matches the target, or provides counterexample (i.e. a word that is in
the hypothesis but not in the target or vice versa) if it does not. Using these
two questions, any regular set can be learned.

\subsection {Data structure}

The algorithm keeps track of a set of \textit{access strings} $S$ and a set of
\textit{distinguishing extensions} $E$. The answer to the queries are stored in
a two dimensional table called an observation table. The columns of this table
are headered by the items of $E$. The rows are split into two parts. The rows of
the upper and lower parts are headered by items from $S$ and $S \concat A$
respectively, where `$\concat$' is the concatenation operator. 

% not quite happy with this phrasing yet.. 
Rows in the observation table correspond to state candidates for the hypothesis.
Two state candidates are considered to represent the same state if they react
identically under the same input (i.e. if the corresponding rows have the same
values under all columns). Consider a cell at the row $x$ labelled by access
string $s$ and column $e$. The value at column $e$ represents whether applying
the string $e$ from the state corresponding to $x$ results in an accepting
state. Equivalently, this can be interpreted to mean whether applying $s \concat
e$ from the initial state results in an accepting state.

\subsection {The algorithm}

The algorithm consists of two phases. The first phase is repeated until a closed
and consistent model is found.

A model is called inconsistent if and only if the observation table contains
distinct rows with identical values under $E$ (i.e. the rows appear to represent
the same state), but inputing some $a \in A$ results in rows with different
values in some $e \in E$. Thus if a model is found to be inconsistent, feeding
the input $a \concat e$ results in different states, and so $a \concat e$ is
discovered to be a distinguishing experiment. Therefore, $a \concat e$ is added
$E$, making the two rows in $S$ become distinct under the columns of $E$, thus
removing the inconsistency. New membership queries are performed in order to
fill in the blank cells in the table.

% dit moet nog even wat beter.. 
A model is considered to be closed if $S \concat A$ doesn't contain any states
that are not in $S$. If there are, the row is moved to $S$. The reason for this
is that if there is a row $x$ in $S \concat A$ that is not in $S$, then it is
unknown how $x$ reacts to $A$, so the current hypothesis of the state machine
does not describe what happens in state $x \concat A$. After moving $x$ to $S$,
the rows $x \concat A$ are added to the lower part of the observation table, and
membership queries are performed the fill in the cells. 
\\\\
In the second phase of the algorithm, the equivalence check is
performed. If the reply is `yes', then the algorithm stops. If instead a counter
example is replied, the counterexample and all of its prefixes are added to $S$,
after which $S \concat A$ is updated and the algorithm moves back to phase 1.

\subsection {Equivalence queries}

In practice, no oracle is available to precisely answer equivalence queries,
because if the oracle knew the exact DFA, the whole algorithm wouldn't be
required. Instead, the answers to equivalence queries are approximated by
repeatedly running random membership queries. For each of these membership
queries, a random sequence of symbols from in input alphabet is generated, and
is then checked against both the proposed DFA and the unknown regular set. If
they do not match, the counterexample is found. This process is repeated until
the desired confidence that the statemachine is correct is reached.

\subsection {Example run}

\end{document}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End: